<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Html布局一把梭(1):flex(弹性布局)</title>
      <link href="/2022/09/29/flex/"/>
      <url>/2022/09/29/flex/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>后端写后端什么时候都是一件麻烦事,但是很多时候又没有前端来配合你,即便有blazor这种js解决方案,但是css还是必须由自己来写. </p><p>在以前CSS布局大多由盒子模型来胜任,其精髓大抵为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//CSS</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011110137.png" alt="盒子模型">  </p><blockquote><p>当然不同的 display 属性下的盒模型是不一样的，上图为display:block情况下的盒模型，当在display:inline、display:table-cell等情况下需要另外考虑。 </p></blockquote><p>在布局时,最烦人的莫过于居左居右居中,原因无他,实现方法太多,CSS的规则就是没有规则,在盒子模型的时候,大抵通过text-align和margin来设置.虽然现在的组件库大抵封装了Row和Col,但是这并不适用所有情况,而,再加上现在项目大抵都有响应式的需求,使得Flex(弹性布局)的地位更为突出.  </p><p>flex是css3加进来的东西,与传统布局对比,flex的兼容性较差,对IE的最低要求为IE 11(2022年了微软都放弃IE了不会有人还在坚持吧?).且在PC上的效果没有移动端好,但是其布局较为简单,快捷.并且原生支持响应式.</p><h2 id="基础对比"><a href="#基础对比" class="headerlink" title="基础对比"></a>基础对比</h2><p>设置了display:flex的元素称为弹性容器，它的所有子元素将称为flex item（弹性项目）。<br>注意：设置了 flex 布局以后，子元素的float、clear和vertical-align属性将失效.<br>如果父元素设置flex的话,普通行内元素(<span>)将可以设置宽高.<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011110811.png" alt="弹性布局">  </p><ul><li>main axis：水平轴主轴</li><li>cross axis：垂直交叉轴</li><li>main start：主轴的开始位置</li><li>main end：主轴的结束位置</li><li>cross start：交叉轴的开始位置</li><li>cross end：交叉轴的结束位置</li><li>main size：单个弹性项目占据的主轴</li><li>cross size：单个弹性项目占据的交叉轴</li></ul><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul><li>flex-direction - 主轴的方向</li><li>flex-wrap - 换行方式</li><li>flex-flow - direction和wrap的简写</li><li>justify-content - 主轴对齐方式</li><li>align-items - 交叉轴对齐方式</li><li>align-content - 多根轴线对齐方式</li></ul><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>它决定了主轴的方向，就是弹性项目的方向 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011111619.png">  </p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011111700.png">  </p><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>它是flex-direction和flex-wrap的简写，默认值为：row nowrap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>它来设置项目在主轴(默认是水平方向)上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011112231.png">  </p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>它来设置项目在交叉(默认是垂直方向)轴上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011112306.png">  </p><blockquote><p>baseline 是文字在同一水平线上:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011112630.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011112652.png">  </p></blockquote><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>它定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注意,在flex中没有justify-items这个属性,它是盒子模型中的属性</strong></em></p><hr><h3 id="align-items和align-content区别"><a href="#align-items和align-content区别" class="headerlink" title="align-items和align-content区别"></a>align-items和align-content区别</h3><p>align-items : 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。</p><p>center：元素位于容器的中心。<br>弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。<br>align-items:center</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011113534.png">  </p><p>align-content：会设置自由盒内部所有行作为一个整体在垂直方向排列方式。针对多行作为一个整体在纵轴上的排列方式，该属性对单行无效。</p><p>center：元素位于容器的中心。<br>各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。（如果剩下的空间是负数，则各行会向两个方向溢出的相等距离。）<br>容器内必须有多行的项目，该属性才能渲染出效果。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011113549.png"><br>简而言之,一个对应每一项,一个对应整体. </p><hr><h3 id="弹性项目的属性"><a href="#弹性项目的属性" class="headerlink" title="弹性项目的属性"></a>弹性项目的属性</h3><ul><li>order - 排序顺序</li><li>flex-grow - 放大比例</li><li>flex-shrink - 缩小比例</li><li>flex-basis - 理想空间</li><li>flex -grow,-shrink和-basis的简写</li><li>align-self - 单个项目对齐方式</li></ul><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它是用来定义项目的排列顺序，数字越小，排列靠前，默认为<span class="number">0</span>。</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011114018.png">  </p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>这个属性是用来设置项目的空间占比比例，默认为0，即如果存在剩余空间也不占用；如果说有的项目的flex-grow属性都为1，那么它们会均分剩余的空间，如果一个项目的flex-grow属性为2，其他项目都为1，则为2的占据的剩余空间将比其他项多一倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011114129.png">  </p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>这个属性是用来设置项目的缩小比例，默认1，如果空间不足，则该项目缩小；如果一个项目的flex-shrink的属性为0，其它为1，则空间不足时，前者不缩小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011114518.png">  </p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>flex-basis表示在flex items 被放入flex容器之前的大小，也就是items的理想或者假设大小，但是并不是其真实大小，其真实大小取决于flex容器的宽度.<br>当flex-basis和width属性同时存在时，width属性不生效，flex item的宽度为flex-basis设置的宽度<br>当flex空间不够时，由于flex-shrink的默认值为1，所以所有flex items容器等比例被压缩</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>它是属性flex-grow、flex-shrink和flex-basis的简写，默认值为0 1 auto，后两个属性为可选项。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>它是用来设置单个项目的在交叉轴上的对齐方式，它会覆盖align-items属性的值，默认值为auto，即继承了父级元素的align-items属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/flex/20221011115151.png">  </p><p><em><strong>仍然没有justify-self这个属性</strong></em></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://www.jianshu.com/p/8c4cddb1b3c8">CSS 盒模型 vs Flex 布局</a></li><li><a href="https://juejin.cn/post/6968365405257596958">flex布局与传统布局对比</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> flex </tag>
            
            <tag> css3 </tag>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EF Core导航属性那点事</title>
      <link href="/2022/08/23/EFNavigation/"/>
      <url>/2022/08/23/EFNavigation/</url>
      
        <content type="html"><![CDATA[<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>EF默认情况下的依赖推测已经相当敏捷了,在大部分情况下都不用去指定依赖关系,比如在下面这种的博客-用户-标签关系中:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Blog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Tag&gt; Tags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> User Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AuthorId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>  Id</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Blog&gt; Blog &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Tag</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Blog&gt; Blogs &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种依赖关系非常常见,博客跟用户是一对多,博客跟标签是多对多.这种情况下不需要做额外配置,包括中间表BlogTag EF也会隐式帮我们生成.包括Blog如果不显式设置UserId也会生成一个对应的外键(EF里面叫影子外键)</p><p>这种情况下依赖关系是很明确的,但是在新增的时候有一个问题,比如我只指定了Blog的Auhtor,而没有去指定UserId,然后用DbConetxt去Add呢?比如:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blog = <span class="keyword">new</span> Blog&#123;</span><br><span class="line">    Author = <span class="keyword">await</span> dbContext.FindAsync(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> dbContext.AddAsync(blog);</span><br><span class="line"><span class="keyword">await</span> dbContext.SaveChangesAsync();</span><br></pre></td></tr></table></figure><p>这种情况下EF会尝试把Author当新值去插入,但是由于此情况下User是已经存在的项,插入的时候自然会报错.在这个<a href="https://stackoverflow.com/a/50906962/15117498">回答</a>中解释了这一点,并给出了三种解决方案:</p><ul><li>修改实体状态为Added而不是使用Add方法: <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_context.Entry(Product).State = EntityState.Added;</span><br><span class="line"><span class="keyword">await</span> _context.SaveChangesAsync();</span><br></pre></td></tr></table></figure></li><li>在Add之前附加导航属性对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Product.Shop != <span class="literal">null</span>) _context.Attach(Product.Shop);</span><br><span class="line">_context.Products.Add(Product);</span><br><span class="line"><span class="keyword">await</span> _context.SaveChangesAsync();</span><br></pre></td></tr></table></figure></li><li>使用Update代替Add  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_context.Products.Update(Product);</span><br><span class="line">await _context.SaveChangesAsync();</span><br></pre></td></tr></table></figure>在实际中,<del>我选择第三个方法会导致第二次Update会出现主键冲突错误,而第一种方案没有这个问题</del>.答案末尾也针对不推荐使用这种方法的原因说明了:<blockquote><p>The last technique is explained in Saving Data - Disconnected Entities - Mix of new and existing entities:</p><blockquote><p>With auto-generated keys, Update can again be used for both inserts and updates, even if the graph contains a mix of entities that require inserting and those that require updating  </p></blockquote><p>Since it works only when all entities use auto-generated PKs, and also produces unnecessary updates of the related entities, I don’t recommend it.</p></blockquote></li></ul><p><strong>主键冲突错误是因为在Blazor中使用DbContextFacotry产生的DbContext不一致的原因,与Update无关</strong></p><h3 id="复杂导航属性"><a href="#复杂导航属性" class="headerlink" title="复杂导航属性"></a>复杂导航属性</h3><p>比如上述场景,如果文章多出一个联合发布人的情况:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Blog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Tag&gt; Tags &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> User Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; UnionAuthor &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AuthorId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>  Id</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Blog&gt; Blog &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Blog&gt; UnionBlog &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下EF没法识别依赖关系,需要在OnModelCreating中指定这点</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .HasOne(t =&gt; t.Author)</span><br><span class="line">            .WithMany(t =&gt; t.Blog)</span><br><span class="line">            .HasForeignKey(t=&gt;t.AuthorId);</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">            .HasMany(t =&gt; t.UnionAuthor)</span><br><span class="line">            .WithMany(t =&gt; t.UnionBlog);</span><br></pre></td></tr></table></figure><h3 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h3><p>转换器是EF Core2.1带来的功能,按理来说转换器不属于导航属性的内容,但是它是反其道而行,可以在一定程度上避免使用导航属性,比如在Blog中添加一个<code>List&lt;string&gt; Imgs</code>这种情况,在以前情况无法直接去定义这种属性,不得不去额外定义一个表,而值转换器解决了这个问题:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">           .Property(e =&gt; e.Imgs)</span><br><span class="line">           .HasConversion(</span><br><span class="line">               v =&gt; <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, v != <span class="literal">null</span> ? v.ToArray() : Enumerable.Empty&lt;<span class="built_in">string</span>&gt;()),</span><br><span class="line">               v =&gt; v.Split(<span class="string">&#x27;,&#x27;</span>, StringSplitOptions.RemoveEmptyEntries),</span><br><span class="line">               <span class="keyword">new</span> ValueComparer&lt;ICollection&lt;<span class="built_in">string</span>&gt;&gt;(</span><br><span class="line">                   (c1, c2) =&gt; c1 != <span class="literal">null</span> &amp;&amp; c2 != <span class="literal">null</span> &amp;&amp; c1.SequenceEqual(c2),</span><br><span class="line">                   c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">                   c =&gt; c));</span><br></pre></td></tr></table></figure><p><code>HasConversion</code>第一个参数为序列化方法,第二个参数为反序列方法,第三个则为值比较方法(用于实体追踪)<br>不仅仅是List,也可以转换各种结构体或者类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IList</span>&lt;<span class="title">AnnualFinance</span>&gt; Finances</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;()</span><br><span class="line">    .Property(e =&gt; e.Finances)</span><br><span class="line">    .HasConversion(</span><br><span class="line">        v =&gt; JsonSerializer.Serialize(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        v =&gt; JsonSerializer.Deserialize&lt;List&lt;AnnualFinance&gt;&gt;(v, (JsonSerializerOptions)<span class="literal">null</span>),</span><br><span class="line">        <span class="keyword">new</span> ValueComparer&lt;IList&lt;AnnualFinance&gt;&gt;(</span><br><span class="line">            (c1, c2) =&gt; c1.SequenceEqual(c2),</span><br><span class="line">            c =&gt; c.Aggregate(<span class="number">0</span>, (a, v) =&gt; HashCode.Combine(a, v.GetHashCode())),</span><br><span class="line">            c =&gt; (IList&lt;AnnualFinance&gt;)c.ToList()));</span><br></pre></td></tr></table></figure><p>这种序列号也就相当于EF自动处理了以前在业务层写的序列化转换部分.除了自定义转换器外,EF Core也内置了一些默认转换器,比如最简单的Bool to Int(在Sqlite中就会默认执行此处理):</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    modelBuilder</span><br><span class="line">        .Entity&lt;User&gt;()</span><br><span class="line">        .Property(e =&gt; e.IsActive)</span><br><span class="line">        .HasConversion&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://docs.microsoft.com/zh-cn/ef/core/modeling/value-conversions?tabs=data-annotations">EF文档-值转换</a></li><li><a href="https://stackoverflow.com/questions/50889676/ef-core-one-to-many-relationship-throw-exception-cannot-add-or-update-a-child-ro">ef core one to many relationship throw exception Cannot add or update a child row</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Entity Framework </tag>
            
            <tag> 备忘录 </tag>
            
            <tag> EF Core </tag>
            
            <tag> 导航属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core中的认证与授权</title>
      <link href="/2022/08/17/Authentication/"/>
      <url>/2022/08/17/Authentication/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>无论做什么应用,除非是完全公开的静态官网,总是会接触到认证与授权这两个概念.也许在小项目中这二者经常被混淆甚至误用,但是在现代化应用中,二者职责已相当分明,前者判断你是否合法,比如你登录爱奇艺时,认证中间件只判断账号密码是否正确,而当你点进一部新剧时,授权中间件则会对你账号的进行鉴权,比如是否有会员,是否有试看卷,通俗点来说,认证是鉴别用户是谁,而授权则是判断用户能做什么.</p><p>在ASP.NET core中认证是Authentication,授权是Authorization.也就是在项目入口中经常添加的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseAuthentication()</span><br><span class="line">app.UseAuthorization();</span><br></pre></td></tr></table></figure><p>不同于以前在PHP中随便写写Cookie login,现在对安全的提高和权限的细分,已经使传统的基于Cookie和Session的认证方式无法完成部分环境要求(比如前后端分离后,部分接口认证转向JWT,或者Oauth2的授权码模式),传统ASP.NET MVC应用中,通常使用IdentityServier或者直接在Controller校验后HttpClient.Sigin(),现在这种方式仍然予以保留.在ASP.NET Core中由于框架被细分(例如Blazor、WebAPI、grpc),对这块权限跨分极为精密,能做的更广也更为精确.  </p><h2 id="Cliam-标识-和ClaimsIdentity-证件"><a href="#Cliam-标识-和ClaimsIdentity-证件" class="headerlink" title="Cliam(标识)和ClaimsIdentity(证件)"></a>Cliam(标识)和ClaimsIdentity(证件)</h2><p>首先,ASP.NET Core中定义的最小身份信息是<code>Cliam</code>,原意是声明或者主张,不必在意翻译是否准确,可以将它理解为证件上的某一项标识,比如身份证上的姓名:张三、性别:男或者身份证号:101XXXXXXXXXXXX等等,这些都可以看成一个个键值对,Key是类型(CliamType&#x2F;string),Value是具体值(string),并且这种键值对是可以重用的,比如你身份证和你驾照上的身份证上就有相同的标识,我们就不必去重复定义标识,不同标识可以组合成不同的证件,而这个”证件”在ASP.NET Core中是<code>ClaimsIdentity</code>,如果把前者理解为键值对,后者可以理解为<code>SortedList</code>(可重复键值对).有时候一个证件不足以证明一个人的身份,一个人也可以拥有多张证件.而这个证件持有人就是<code>ClaimsPrincipal </code>.  </p><p>想象一下,写字楼大门保安只看你的工牌是否属于写字楼里面某个楼层的公司,那他就没有必要在乎你上面的名字,而等你进入公司后,公司又需要判断你的级别,不至于把普通员工安排到总经理办公室.等你下班后,你小区的保安又需要你小区的门禁卡,即便你们公司的工牌上和门禁卡上的姓名标识是一样的,保安也不会看你的工牌就放你进去,但是如果你恰巧没带门禁卡,却带着房产证的话,看房产证的信息判断你是小区业主,依然可以放行.  </p><p>这几个场景下,要求的验证信息和方式各不相同不同,写字楼保安只在乎你的工牌上是否标识了某个公司,不管你是男是女;而公司需要你的工牌属于公司且需要查看工牌的身份信息;小区保安则要求你出示的是小区的门禁卡,至于你进入小区后怎么刷卡坐电梯那就是另一回事.应用到上面的<code>Cliam</code>和<code>ClaimsIdentity</code>,写字楼保安需要你的<code>Cliam</code>的Type是公司,Key是写字楼的某一项公司,并不关心你的ClaimsIdentity.而公司则需要你的<code>ClaimsIdentity</code>是XXX公司的工牌,并会查看你的<code>ClaimsIdentity</code>中<code>Cliam Type</code>为部门的值.而小区保安则判断你的<code>ClaimsPrincipal</code>是否为业主,而不在乎你拿什么证件来证明.</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>想象一下,如果需要自定义一个从数据库中验证并且有状态的Token认证,这和使用jwt或者其它token方案都不相同,那么需要如何操作呢?<br>在ASP.NET Core中,无论是认证还是授权,都是方案对应一个处理程序.其中,认证时的认证方案由<code>Authorize</code>特性的<code>AuthenticationSchemes</code>指定,所以,我们先需要添加一个认证方案:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddAuthentication(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    opt.AddScheme&lt;TokenAuthentication&gt;(<span class="string">&quot;CustomToken&quot;</span>, <span class="string">&quot;Token&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>认证方案添加了,在定义认证处理程序,认证方案需要实现IAuthenticationHandler:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenAuthentication</span> : <span class="title">IAuthenticationHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpContext _context = <span class="literal">default</span>!;</span><br><span class="line">    <span class="keyword">private</span> AppDbContext _dbContext = <span class="literal">default</span>!;</span><br><span class="line">    <span class="keyword">private</span> AuthenticationScheme _scheme = <span class="literal">default</span>!;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InitializeAsync</span>(<span class="params">AuthenticationScheme scheme, HttpContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _context = context;</span><br><span class="line">        _scheme = scheme;</span><br><span class="line">        <span class="keyword">await</span> Task.FromResult(_dbContext = context.RequestServices.GetRequiredService&lt;AppDbContext&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;AuthenticateResult&gt; <span class="title">AuthenticateAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> haveToken = _context.Request.Headers.TryGetValue(<span class="string">&quot;Authorization&quot;</span>, <span class="keyword">out</span> <span class="keyword">var</span> tokenHeader);</span><br><span class="line">        <span class="built_in">string</span> token = haveToken ? tokenHeader.ToString()[<span class="string">&quot;Bearer &quot;</span>.Length..] : <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (haveToken &amp;&amp; <span class="keyword">await</span> _dbContext.Users.SingleOrDefaultAsync(t =&gt; t.Token == token) <span class="keyword">is</span> User user)<span class="comment">//验证token是否正确</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里的ClaimsIdentity构参scheme一定要和注入服务的scheme一样,除非此认证处理程序是默认的情况</span></span><br><span class="line">            ClaimsIdentity claimsIdentity = <span class="keyword">new</span> ClaimsIdentity(<span class="keyword">nameof</span>(TokenAuthentication));</span><br><span class="line">            claimsIdentity.AddClaims(<span class="keyword">new</span> Claim[]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> (ClaimTypes.Name, user.Name!),</span><br><span class="line">                <span class="keyword">new</span> (ClaimTypes.Sid, user.Id.ToString()!)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//鉴权成功，写入用户信息</span></span><br><span class="line">            <span class="keyword">return</span> AuthenticateResult.Success(<span class="keyword">new</span> AuthenticationTicket(<span class="keyword">new</span> ClaimsPrincipal(claimsIdentity), _scheme.Name));</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> AuthenticateResult.NoResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ChallengeAsync</span>(<span class="params">AuthenticationProperties? properties</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.FromResult(_context.Response.StatusCode = <span class="number">401</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ForbidAsync</span>(<span class="params">AuthenticationProperties? properties</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.FromResult(_context.Response.StatusCode = <span class="number">403</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完事在控制器或者Action中指定Schemes即可:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize(AuthenticationSchemes = <span class="string">&quot;CustomToken&quot;</span>)</span>]</span><br></pre></td></tr></table></figure><h2 id="角色授权"><a href="#角色授权" class="headerlink" title="角色授权"></a>角色授权</h2><p>在传统应用中RBAC(基于角色的访问控制)大行其道,在现如今的后台管理中依然适用,比如上面励志中,只需要定义公司员工和小区业主身份,并对应添加允许通行、坐电梯、停地下停车场等权限,就可以根据不同身份控制权限,并且同一用户可以同时拥有多个角色.具有一定的灵活性.</p><p>在ASP.NET Core中仍旧支持此种授权方式,添加认证和鉴权中间件后,我们可以在控制器或者具体方法上使用<code>[Authorize]</code>特性的Role来控制其角色要求.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二者都可访问</span></span><br><span class="line">[<span class="meta">Authorize(Roles = <span class="string">&quot;Administrator, PowerUser&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ControlAllPanelController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">SetTime</span>()</span> =&gt;</span><br><span class="line">        Content(<span class="string">&quot;Administrator || PowerUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅支持Administrator访问</span></span><br><span class="line">    [<span class="meta">Authorize(Roles = <span class="string">&quot;Administrator&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">ShutDown</span>()</span> =&gt;</span><br><span class="line">        Content(<span class="string">&quot;Administrator only&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录的时候在ClaimsPrincipal中写入角色claim:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的ClaimsIdentity构参scheme一定要和注入服务的scheme一样,无论是默认还是自定义认证服务</span></span><br><span class="line"><span class="keyword">var</span> identity = <span class="keyword">new</span> ClaimsIdentity(<span class="keyword">new</span> ClaimsIdentity(CookieAuthenticationDefaults.AuthenticationScheme));</span><br><span class="line"><span class="comment">//自定义的claim信息</span></span><br><span class="line">identity.AddClaim(<span class="keyword">new</span> Claim(ClaimTypes.Role, <span class="string">&quot;Administrator&quot;</span>));</span><br><span class="line">identity.AddClaim(<span class="keyword">new</span> Claim(ClaimTypes.Role, <span class="string">&quot;PowerUser&quot;</span>));</span><br><span class="line">AuthenticationProperties properties = <span class="keyword">new</span> AuthenticationProperties()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置cookie票证的过期时间</span></span><br><span class="line">    ExpiresUtc = DateTime.Now.AddDays(<span class="number">7</span>),</span><br><span class="line">    RedirectUri = model.ReturnUrl</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">await</span> HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, <span class="keyword">new</span> ClaimsPrincipal(identity), properties);</span><br></pre></td></tr></table></figure><blockquote><p>由于ClaimsIdentity内的键值对是可重复的,所以可以直接Add多个同Type的Claim(<code>ClaimTypes.Role</code>).</p></blockquote><p>RBAC大行其道,但是在某些情况下它缺乏一定的灵活性,比如现在新开了个网吧,需要18岁以上的成年人才可进入,如果在这里加一个可进入酒吧的权限,那后面再多一个只准12岁以下进入的游乐场或者只准60岁以下进入的鬼屋,难不成都要逐个加么?</p><p>基于此种应用需求,微软引入了声明和策略授权.</p><h2 id="声明授权"><a href="#声明授权" class="headerlink" title="声明授权"></a>声明授权</h2><p>回到上面所述的,小区保安只关心你有没有小区业主的身份,也不关心具体在几栋在几楼,我们可以做如下定义:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line">builder.Services.AddRazorPages();</span><br><span class="line">builder.Services.AddControllersWithViews();</span><br><span class="line"></span><br><span class="line">builder.Services.AddAuthorization(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   options.AddPolicy(<span class="string">&quot;Owner&quot;</span>, policy =&gt; policy.RequireClaim(<span class="string">&quot;Residential&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line">app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">app.UseAuthentication();</span><br><span class="line"></span><br><span class="line">app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">app.MapDefaultControllerRoute();</span><br><span class="line"></span><br><span class="line">app.MapRazorPages();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>在控制器或者Action上方标注授权要求:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize(Policy = <span class="string">&quot;EnsureSafety&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">EnterCommunity</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> View();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,也是支持多重策略应用的,比如进入小区保安只管你业主身份,但是单元楼楼下有个大妈防着小偷,一定要熟面孔才让进:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业主策略</span></span><br><span class="line">[<span class="meta">Authorize(Policy = <span class="string">&quot;Owner&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommunityController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">EnterCommunity</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//熟人策略</span></span><br><span class="line">    [<span class="meta">Authorize(Policy = <span class="string">&quot;Acquaintance&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">EnterUnitBuilding</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略授权"><a href="#策略授权" class="headerlink" title="策略授权"></a>策略授权</h2><p>上述声明授权中,虽然说的是声明授权,但是定义却是用的AddPolicy,这不是添加策略的意思么?<br>其实,策略可以看作声明和角色的并集,所以使用策略授权定义声明也就没什么好奇怪的了.</p><blockquote><p>基于角色的授权和基于声明的授权，只是一种语法上的便捷，最终都会生成授权策略</p></blockquote><p>接着是上面所说的网吧最低年龄这种限制,我们可以添加一个自定义授权策略:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义授权要求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MinimumAgeRequirement</span> : <span class="title">IAuthorizationRequirement</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinimumAgeRequirement</span>(<span class="params"><span class="built_in">int</span> minimumAge</span>)</span> =&gt;</span><br><span class="line">        MinimumAge = minimumAge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MinimumAge &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对授权要求使用处理程序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MinimumAgeHandler</span> : <span class="title">AuthorizationHandler</span>&lt;<span class="title">MinimumAgeRequirement</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task <span class="title">HandleRequirementAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        AuthorizationHandlerContext context, MinimumAgeRequirement requirement</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dateOfBirthClaim = context.User.FindFirst(c =&gt; c.Type == ClaimTypes.DateOfBirth);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dateOfBirthClaim <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> dateOfBirth = Convert.ToDateTime(dateOfBirthClaim.Value);</span><br><span class="line">        <span class="built_in">int</span> calculatedAge = DateTime.Today.Year - dateOfBirth.Year;</span><br><span class="line">        <span class="keyword">if</span> (dateOfBirth &gt; DateTime.Today.AddYears(-calculatedAge))</span><br><span class="line">        &#123;</span><br><span class="line">            calculatedAge--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (calculatedAge &gt;= requirement.MinimumAge)</span><br><span class="line">        &#123;</span><br><span class="line">            context.Succeed(requirement);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理程序通过调用 context.Succeed(IAuthorizationRequirement requirement) 并传递已成功验证的要求来指示成功。</li><li>处理程序通常不需要处理失败，因为针对相同要求的其他处理程序可能会成功。</li><li>为了保证失败，即使其他要求处理程序成功，也需调用 context.Fail。</li></ul><p>添加自定义授权要求,并注入对应处理程序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddAuthorization(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.AddPolicy(<span class="string">&quot;AtLeast18&quot;</span>, policy =&gt;</span><br><span class="line">        policy.Requirements.Add(<span class="keyword">new</span> MinimumAgeRequirement(<span class="number">18</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">builder.Services.AddSingleton&lt;IAuthorizationHandler, MinimumAgeHandler&gt;();</span><br></pre></td></tr></table></figure><p>一个授权策略可以添加多个要求,可以按照需求添加多个要求甚至直接组合.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authorization/">ASP.NET Core 中的授权简介</a></li><li><a href="https://www.cnblogs.com/rainingnight/p/introduce-basic-authentication-in-asp-net-core.html">ASP.NET Core 认证与授权</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> asp.net core </tag>
            
            <tag> 认证 </tag>
            
            <tag> 鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域驱动ABP框架入门基础</title>
      <link href="/2022/07/08/ABP/"/>
      <url>/2022/07/08/ABP/</url>
      
        <content type="html"><![CDATA[<h1 id="ABP框架入门基础"><a href="#ABP框架入门基础" class="headerlink" title="ABP框架入门基础"></a>ABP框架入门基础</h1><p>ABP是一个开源且文档友好的应用程序框架。ABP不仅仅是一个框架，它还提供了一个最徍实践的基于领域驱动设计(DDD)的体系结构模型，可以支持 .net framework和 .net core两种技术流派。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="领域驱动"><a href="#领域驱动" class="headerlink" title="领域驱动"></a>领域驱动</h3><p>基于它的设计理念,在介绍ABP之前,先简单介绍下领域驱动概念设计.<br>领域驱动(Domain-Driven Design ),并不是一种技术架构，而是一种划分业务领域范围的方法论。具体来说它是一种拆解业务、划分业务、确定业务边界的方法， 是一种高度复杂的领域设计思想，将问题拆分成一个个的域，试图分离技术实现的复杂性，主要解决的是软件难以理解难以演进的问题，目的就是将复杂问题领域简单化，帮助我们设计出清晰的领域和边界，可以很好的实现技术架构的演进。  </p><p>以保险业务为例来进行编程实践，一个高度抽象的保险领域划分如图所示。通过用例分析，我们把整个业务划分成产品域、承保、核保、理赔等多个领域（Bounded-Context），每个领域又可以根据业务发展情况拆分子域。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220815141237.png">  </p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>在每个领域内部，相对于 MVC 对应用三层架构的拆分，领域驱动的设计将应用模块内部分为如图示的四层。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220815141500.png">  </p><ul><li>用户接口(表示层): 为用户提供接口. 使用应用层实现与用户交互.</li><li>应用层: 表示层与领域层的中介,编排业务对象执行特定的应用程序任务. 使用应用程序逻辑实现用例.</li><li>领域层: 包含业务对象以及业务规则. 是应用程序的核心.</li><li>基础设施层: 提供通用的技术功能,支持更高的层,主要使用第三方类库.</li></ul><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul><li><p>领域层:</p><ul><li>实体:DDD中要求实体是唯一的且可持续变化的。业务中最常见的唯一标识的用户就是实体,比如普通人通过身份证对其进行唯一标识,不管你年龄住址等信息如何变动,你依然是你.</li><li>聚合与聚合根:我们把一些关联性极强、生命周期一致的实体、值对象放到一个聚合里。聚合是领域对象的显式分组，旨在支持领域模型的行为和不变性，同时充当一致性和事务性边界。如果聚合根比喻成一个小组,那么聚合根就是组长,通过他可以快速定位到这个小组. 以上面所属的保险行业为例定义的聚合和聚合根:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220815144413.png">  </li><li>值对象:当你只关心某个对象的属性时，该对象便可作为一个值对象。 我们需要将值对象看成不变对象，不要给它任何身份标识，还应该尽量避免像实体对象一样的复杂性。比如上面保单的客户实体,他的地址就可以看成一个值对象.</li><li>仓储:仓储介于领域模型和数据模型之间，主要用于聚合的持久化和检索。它隔离了领域模型和数据模型.这点其实和我们以往在EF Core或者FreeSql上使用的仓储模式区别不大.</li><li>领域服务:领域中的一些概念不太适合建模为对象，即归类到实体对象或值对象，因为它们本质上就是一些操作，一些动作，而不是事物。  <ul><li>可以使用领域服务的情况：<ul><li>执行一个显著的业务操作</li><li>对领域对象进行转换</li><li>以多个领域对象作为输入参数进行计算，结果产生一个值对象</li></ul></li></ul></li><li>规约:顾名思义,是一些规则&#x2F;约束条件,比如银行在贷款的时候会考虑对方的还款能力和信用记录,这里的考虑条件就是规约.</li></ul></li><li><p>应用服务层</p><ul><li>应用服务:应用服务实现应用程序的用例, 将领域层逻辑公开给表示层,从表示层(可选)调用应用服务,DTO (数据传输对象) 作为参数. 返回(可选)DTO给表示层.这有点类似Controller.</li><li>数据传输对象(DTO):用于在应用层和表示层或其他类型的客户端之间传输数据,这在ABP中是可选但是推荐使用的,其实就是一直在用的视图模型(Req&#x2F;Rsp)</li><li>工作单元(UOW):提供了对应用程序中的数据库连接和事务范围的抽象和控制.ABP的工作单元按约定工作, 所以大部分情况下你不需要处理UOW,一旦一个新的UOW启动,它将创建一个环境作用域,当前作用域中执行的所有数据库操作都将参与该作用域并将其视为单个事务边界. 操作一起提交(成功时)或回滚(异常时).</li></ul></li></ul><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>以官方文档的Web MVC Razor应用程序为例:<br>需要先安装Node.js 12&#x2F;14<br>安装ABP CLI:<br><code>dotnet tool install -g Volo.Abp.Cli</code><br>更新:<br><code>dotnet tool update -g Volo.Abp.Cli</code><br>创建项目模板:  </p><ul><li>默认MVC: <code>abp new Acme.BookStore</code>  </li><li>WebAPI: <code>abp new Acme.BookStore -u none</code><blockquote><p><strong>如果运行时提示找不到库文件,请使用PowerShell执行以下命令安装Npm包:</strong>  </p><ol><li>Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process  </li><li>npm install -g npm-windows-upgrade  </li><li>npm-windows-upgrade</li></ol></blockquote></li></ul><p>可以得到下图的项目结构:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220815154934.png"><br>其中,Acme.BookStore.DbMigrator项目为数据库迁移项目,初次运行它,会自动安装ef tool(如果使用ef core)进行数据库迁移并设置种子数据.<br>项目分层及依赖结构:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220815155252.png">  </p><ul><li>Domain：主要包含实体和域服务</li><li>Domain.Shared：可以与客户端共享的其他与域相关的对象（枚举或其它与实体相关的用于引用<br>的类）,比如本地化文件.</li><li>EntityFrameworkCore：EF Core的集成项目</li><li>Application.Contracts：包含应用服务(Service)的接口(IService)以及应用服务层(.Application)的<br>DTO(Data Transfer Objects)</li><li>Application：包含应用服务(Service)，是.Application.Contracts中的IService接口实现</li><li>HttpApi: 用于定义API Controllers</li><li>HttpApi.Client：定义C#客户端代理以使用解决方案的HTTP API的项目，可以将此库共享给第三方<br>客户端以便在其他DotNet应用程序中使用该项目HTTP API<br>其中,运行项目Web根据创建模板也有命名差异,比如为Blazor模板时即为Blazor,如果是使用WebAPI模板,则为HttpApi.Host,其中除了program.cs外,还有<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220816105806.png"><br><code>&#123;项目模板名&#125;Module</code> 、 <code>&#123;项目模板名&#125;BrandingProvider</code> 、 <code>&#123;项目模板名&#125;AutoMapperProfile</code><br>三个类,其中最重要的<code>Module</code>是整个项目的配置文件类,大部分配置项都在其中定义,比如路由、I18N、中间件等等;<code>AutoMapperProfile</code>则是自动映射工具的配置规则(默认集成了AutoMapper);<code>BrandingProvider</code>则是MVC&#x2F;Razor下UI层的视图显示配置(比如AppName和LogoUrl之类的).</li></ul><h4 id="默认集成类库"><a href="#默认集成类库" class="headerlink" title="默认集成类库"></a>默认集成类库</h4><p>列举一些ABP自带和集成的一些常用、可选的工具类库:</p><table><thead><tr><th>用途</th><th>类库</th></tr></thead><tbody><tr><td>日志</td><td>Serilog</td></tr><tr><td>依赖注入</td><td>AutoFac</td></tr><tr><td>对象映射</td><td>AutoMapper</td></tr><tr><td>模型验证</td><td>FluentValidation</td></tr><tr><td>权限控制</td><td>IdentityServer4</td></tr><tr><td>后台作业</td><td>Hangfile&#x2F;RabbitMQ&#x2F;Quartz</td></tr><tr><td>虚拟文件</td><td>VirtualFileSystem</td></tr><tr><td>分布式锁</td><td>DistributedLock</td></tr><tr><td>单元测试</td><td>xunit</td></tr></tbody></table><h3 id="模板应用"><a href="#模板应用" class="headerlink" title="模板应用"></a>模板应用</h3><p>以官网教程为例,对一本书的最简单的增删改查操作流程如下:<br>创建实体模型:<br>在Domain下添加实体模型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span>:<span class="title">AuditedAggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span>(<span class="params">Guid id</span>):<span class="title">base</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">MaxLength(120)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ConverUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Publisher &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime PublicationDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ABP为实体提供了两个基本的基类: AggregateRoot和Entity.也就是我们上文提到的聚合根和实体——聚合根一定定义的是实体<br><code>BasicAggregateRoot</code> 是创建聚合根的最简单的基础类,AggregateRoot在其之上添加了一些基础审计功能,比如(CreationTime、CreatorId、 LastModificationTime、LastModifierId等). <code>Guid</code> 是实体的主键 (Id).添加默认有参构造函数来确保主键不会在误操作下被无序生成(比如对象映射时),在插入时,通过IGuidGenerator.Create()(ApplicationService中默认包含)来产生有序Guid.<strong>永远不要使用Guid.New()来生成主键</strong><br>然后在<code>EntityFrameworkCore</code>项目下的<code>&#123;项目名&#125;DbContext</code>类中添加DbSet</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>添加完成后,分别使用ef tool的<code>add-migrattion up</code>和<code>update-database</code>将添加迁移并更更新到数据库中.<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220815170248.png"><br>然后在<code>Application.Contract</code>中添加<code>IBookAppService</code>接口和<code>BookDto</code>类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAddReq</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAddReq</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ConverUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Publisher &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">DataType(DataType.Date)</span>]</span><br><span class="line">    <span class="keyword">public</span> DateTime PublicationDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookRsp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ConverUrl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Publisher &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime PublicationDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBookAppService</span> : <span class="title">IApplicationService</span></span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;List&lt;BookRsp&gt;&gt; GetListAsync();</span><br><span class="line">    <span class="function">Task&lt;BookRsp&gt; <span class="title">CreateAsync</span>(<span class="params">BookAddReq req</span>)</span>;</span><br><span class="line">    <span class="function">Task <span class="title">DeleteAsync</span>(<span class="params">Guid id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IApplicationService并没有定义任何操作方法,也可以通过实现ICrudAppService来定义最基础的CURD方法<br>在AutoMapperProfile中设置对象映射关系(如果使用AutoMapper的话):</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CreateMap&lt;BookAddReq, Book&gt;();</span><br><span class="line">CreateMap&lt;Book, BookRsp&gt;();</span><br></pre></td></tr></table></figure><p>然后在<code>Application</code>中实现<code>IBookService</code>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用服务需要继承ApplicationService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> : <span class="title">ApplicationService</span>,<span class="title">IBookAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Book, Guid&gt; _bookRepository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookAppService</span>(<span class="params">IRepository&lt;Book, Guid&gt; repository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _bookRepository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;BookRsp&gt; <span class="title">CreateAsync</span>(<span class="params">BookAddReq req</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> book = ObjectMapper.Map(req,<span class="keyword">new</span> Book(GuidGenerator.Create()));</span><br><span class="line">        <span class="keyword">await</span> _bookRepository.InsertAsync(book);</span><br><span class="line">        <span class="keyword">return</span> ObjectMapper.Map&lt;Book, BookRsp&gt;(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DeleteAsync</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _bookRepository.DeleteAsync(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">List</span>&lt;<span class="title">BookRsp</span>&gt;&gt; <span class="title">GetListAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">await</span> _bookRepository.GetListAsync())</span><br><span class="line">            .ToList()</span><br><span class="line">            .Adapt&lt;List&lt;BookRsp&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时,默认的仓储支持通过仓储对象获取dbcontext和Dbset:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dbContext = <span class="keyword">await</span> _bookRepository.GetDbContextAsync();</span><br><span class="line"><span class="keyword">var</span> dbSet = <span class="keyword">await</span> _bookRepository.GetDbSetAsync();</span><br></pre></td></tr></table></figure><p>Service创建完成后,启动项目打开<code>/Swagger</code>,即可看到的Restful API,这部分我们并没有在Controller里面去定义,这是ABP通过动态API默认实现的.<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220816101032.png">  </p><table><thead><tr><th>Service方法名称</th><th>HttpMethod</th><th>路由</th></tr></thead><tbody><tr><td>GetAsync(Guid id)</td><td>GET</td><td>&#x2F;api&#x2F;app&#x2F;book&#x2F;{id}</td></tr><tr><td>GetListAsync()</td><td>GET</td><td>&#x2F;api&#x2F;app&#x2F;book</td></tr><tr><td>CreateAsync(CreateBookDto input)</td><td>POST</td><td>&#x2F;api&#x2F;app&#x2F;book</td></tr><tr><td>UpdateAsync(Guid id, UpdateBookDto input)</td><td>PUT</td><td>&#x2F;api&#x2F;app&#x2F;book&#x2F;{id}</td></tr><tr><td>DeleteAsync(Guid id)</td><td>DELETE</td><td>&#x2F;api&#x2F;app&#x2F;book&#x2F;{id}</td></tr><tr><td>GetEditorsAsync(Guid id)</td><td>GET</td><td>&#x2F;api&#x2F;app&#x2F;book&#x2F;{id}&#x2F;editors</td></tr><tr><td>CreateEditorAsync(Guid id, BookEditorCreateDto input)</td><td>POST</td><td>&#x2F;api&#x2F;app&#x2F;book&#x2F;{id}&#x2F;editor</td></tr></tbody></table><p>如果不想某个Service或者方法自动生成动态API,可以使用<code>[RemoteService(IsEnabled = false)]</code>特性来禁止生成行为<br>同时,即便不是在Controller中,service依然支持使用标准ASP.NET Core的特性(<code>[HttpPost]</code>, <code>[HttpGet]</code>, <code>[HttpPut]</code>… 等等.)来设置其路由生成行为.但是<strong>无法同时支持<code>[Route]</code>路由特性</strong>;<br>如果需要设置路由,则需要在<code>Module</code>下进行配置  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConfigureAutoApiControllers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Configure&lt;AbpAspNetCoreMvcOptions&gt;(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.ConventionalControllers.Create(<span class="keyword">typeof</span>(BookStoreApplicationModule).Assembly, opt =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//do somethings</span></span><br><span class="line">            <span class="comment">// opt.RootPath 设置根路由</span></span><br><span class="line">            <span class="comment">// opt.UrlControllerNameNormalizer 设置控制器生成</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态API并非ApplicationService的专利,只要实现了IRemoteService,那么就会成为APIController,事实上,ApplicationService就是实现了IRemoteService.</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>上面过程中,可能会注意到在写完Service后,并没有像在Asp.Net Core中使用Service.AddScope()来注入,这是ABP引入了依照约定的服务注册.依照约定你无需做任何事,它会自动完成.  </p><p>固有的注册类型:</p><ul><li>模块类注册为singleton.</li><li>MVC控制器（继承Controller或AbpController）被注册为transient.</li><li>MVC页面模型（继承PageModel或AbpPageModel）被注册为transient.</li><li>MVC视图组件（继承ViewComponent或AbpViewComponent）被注册为transient.</li><li>应用程序服务（实现IApplicationService接口或继承ApplicationService类）注册为transient.</li><li>仓储库（实现IRepository接口）注册为transient.</li><li>域服务（实现IDomainService接口）注册为transient.</li></ul><p>使用接口或者特性进行注册:</p><ul><li>接口注册<ul><li>ITransientDependency 注册为transient生命周期.</li><li>ISingletonDependency 注册为singleton生命周期.</li><li>IScopedDependency 注册为scoped生命周期.</li></ul></li><li>特性注册,使用<code>[Dependency]</code>特性,它具有以下属性:<ul><li>Lifetime: 注册的生命周期:Singleton,Transient或Scoped.</li><li>TryRegister: 设置true则只注册以前未注册的服务.使用IServiceCollection的TryAdd … 扩展方法.</li><li>ReplaceServices: 设置true则替换之前已经注册过的服务.使用IServiceCollection的Replace扩展方法.</li></ul></li></ul><p>当然.你也可以禁用它并使用手动注册,由于其集成了AutoFac,所以也支持属性注入.  </p><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>ABP将Asp.Net Core的Authorize带到了ApplicationService,使得应用服务仍旧支持<code>[Authorize]</code>和<code>[AllowAnonymous]</code>特性.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> [<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorAppService</span> : <span class="title">ApplicationService</span>, <span class="title">IAuthorAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Task&lt;List&lt;AuthorDto&gt;&gt; GetListAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;AuthorDto&gt; <span class="title">GetAsync</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要自定义权限策略,可以按照ASP.NET Core文档进行实施策略授权,但对于简单的 true&#x2F;false 条件(比如是否授予了用户策略) ABP定义了权限系统,可以为特定用户,角色或客户端授权或禁止的简单策略.<br>在Application.Contract下的Permissions文件夹中包含了<code>&#123;项目名&#125;PermissionDefinitionProvider</code>和<code>&#123;项目名&#125;Permission</code>  </p><p>在<code>Permission</code>中可以定义一些权限的硬编码,比如角色名,权限值名之类.<br>在<code>PermissionDefinitionProvider</code>的Define中自定义权限组和权限:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Define</span>(<span class="params">IPermissionDefinitionContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> myGroup = context.AddGroup(BookStorePermissions.GroupName);</span><br><span class="line">    <span class="keyword">var</span> permission = myGroup.AddPermission(<span class="string">&quot;Books&quot;</span>);</span><br><span class="line">    permission.AddChild(<span class="string">&quot;CreateBook&quot;</span>);</span><br><span class="line">    permission.AddChild(<span class="string">&quot;DeleteBook&quot;</span>);</span><br><span class="line">    permission.AddChild(<span class="string">&quot;GetBook&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ABP自带的Web端的权限管理中(如果是带UI的模板)可以看到自定义的权限并将其分配给角色和用户<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220816174421.png" alt="仅当拥有父级权限时子权限才可被选中"><br>ABP会将其进行持久化存入数据库内<br>然后便可以在ApplicationService中设置对应的权限:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize(<span class="string">&quot;Books&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookAppService</span> : <span class="title">ApplicationService</span>,<span class="title">IBookAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Task&lt;List&lt;AuthorDto&gt;&gt; GetListAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Authorize(<span class="string">&quot;CreateBook&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;BookRsp&gt; <span class="title">CreateAsync</span>(<span class="params">BookAddReq req</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebAPI下,ABP在Swagger中默认启用Oauth2授权码模式<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220817135244.png" alt=" Oauth2授权码模式与第三方平台例如微信扫码登录一致,登录后跳转返回jwt"> </p><blockquote><p><strong>由于ABP默认集成了IdentityServer,所以未登录的情况下请求接口会跳转至<code>/Account/Login</code>而非返回401,这会给前端带来困扰.需要在AddAuthentication()中使用JwtBearerDefaults.AuthenticationScheme参数来指定默认的认证方案(IdentityServer默认会使用Cookie方案).</strong></p></blockquote><p>ApplicationService中封装了CurrentUser代替Controller中的User,同时,你也可以使用AuthorizationService来检查权限.</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p> ABP了集成常用的异常处理,大部分情况下都不用自己来自定义业务异常.ABP会自动处理所有异常 .如果是API&#x2F;AJAX请求,会向客户端返回一个标准格式化后的错误消息,默认情况下ABP会执行以下处理:</p><ul><li>自动隐藏内部详细错误 并返回标准错误消息.</li><li>为异常消息的本地化 提供一种可配置的方式.</li><li>自动为标准异常设置 HTTP状态代码 ,并提供可配置选项,以映射自定义异常</li></ul><p>当满足下面任意一个条件时,AbpExceptionFilter 会处理此异常:</p><ul><li>当controller action方法返回类型是object result(而不是view result)并有异常抛出时.</li><li>当一个请求为AJAX(Http请求头中X-Requested-With为XMLHttpRequest)时.</li><li>当客户端接受的返回类型为application&#x2F;json(Http请求头中accept 为application&#x2F;json)时.</li></ul><p>如果异常被处理过,则会自动记录日志并将格式化的JSON消息返回给客户端.<br>绝大部分异常都是业务异常,可以直接使用BusinessException抛出并记录,BusinessException 除了实现IHasErrorCode,IHasErrorDetails ,IHasLogLevel 接口外,还实现了IBusinessException 接口.其默认日志级别为Warning.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span>(<span class="params"><span class="built_in">string</span> code = <span class="literal">null</span>, <span class="built_in">string</span> message = <span class="literal">null</span>, <span class="built_in">string</span> details = <span class="literal">null</span>, Exception innerException = <span class="literal">null</span>, LogLevel logLevel = LogLevel.Warning</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">message, innerException</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Code = code;</span><br><span class="line">        Details = details;</span><br><span class="line">        LogLevel = logLevel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果要直接显示具体错误原因,可以使用UserFriendlyException来抛出,不同于BusinessException只有Code被返回,UserFriendlyException不会对msg和的detail做任何处理.<br>如果需要在异常返回中带上data,可以使用withData或者直接使用设置Data属性:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserFriendlyException(<span class="string">&quot;10001&quot;</span>, <span class="string">&quot;对不起,该id未找到对应的实体&quot;</span>)</span><br><span class="line">           .WithData(<span class="string">&quot;BookId&quot;</span>,<span class="number">123</span>)</span><br><span class="line">           .WithData(<span class="string">&quot;RequestId&quot;</span>,<span class="number">10086</span>);</span><br></pre></td></tr></table></figure><p>返回Data:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;对不起,该id未找到对应的实体&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10001&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;BookId&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;RequestId&quot;</span><span class="punctuation">:</span> <span class="number">10086</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;validationErrors&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同时,ABP会按照以下规则,自动映射常见的异常类型的HTTP状态代码:</p><ul><li>对于 AbpAuthorizationException:<ul><li>用户没有登录,返回 401 (未认证).</li><li>用户已登录,但是当前访问未授权,返回 403 (未授权).</li></ul></li><li>对于 AbpValidationException 返回 400 (错误的请求) .</li><li>对于 EntityNotFoundException返回 404 (未找到).</li><li>对于 IBusinessException 和 IUserFriendlyException (它是IBusinessException的扩展) - 返回403 (未授权) .</li><li>对于 NotImplementedException 返回 501 (未实现) .</li><li>对于其他异常 (基础架构中未定义的) 返回 500 (服务器内部错误) .</li></ul><h4 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h4><p>在前面我们定义了Book聚合根,而最开始我们已经知道聚合根可以找到聚合内的多个实体,而书作为聚合根,理应可以直接定位它的作者,所以我们这里来定义一个作者实体.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Author</span>:<span class="title">FullAuditedAggregateRoot</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime BirthDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShortBio &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Author</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* This constructor is for deserialization / ORM purpose */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">Author</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        Guid id,</span></span></span><br><span class="line"><span class="params"><span class="function">        [NotNull] <span class="built_in">string</span> name,</span></span></span><br><span class="line"><span class="params"><span class="function">        DateTime birthDate,</span></span></span><br><span class="line"><span class="params"><span class="function">        [CanBeNull] <span class="built_in">string</span> shortBio = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetName(name);</span><br><span class="line">        BirthDate = birthDate;</span><br><span class="line">        ShortBio = shortBio;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> Author <span class="title">ChangeName</span>(<span class="params">[NotNull] <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetName</span>(<span class="params">[NotNull] <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = Check.NotNullOrWhiteSpace(</span><br><span class="line">            name,</span><br><span class="line">            <span class="keyword">nameof</span>(name),</span><br><span class="line">            maxLength: AuthorConsts.MaxNameLength</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FullAuditedAggregateRoot</code>由<code>AuditedAggregateRoot</code>继承而来,在此基础上添加了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> IsDeleted &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> Guid? DeleterId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> DateTime? DeletionTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>这三个属性用于实现软删除,完整的FullAudited就相当于封装了这部分审计功能.<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/ABP/20220818134513.png"><br>Author的<code>Name</code>和<code>SetName()</code>限制为私有,构造方法和<code>ChangeName()</code>限制为仅项目内访问,强制其只能使用领域服务设置名字.<code>Check()</code>是ABP所提供的检查类,会用来校验方法是否合法并设置值.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorManager</span> : <span class="title">DomainService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository&lt;Author,Guid&gt; _authorRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorManager</span>(<span class="params">IRepository&lt;Author, Guid&gt; authorRepository</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _authorRepository = authorRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;Author&gt; <span class="title">CreateAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        [NotNull] <span class="built_in">string</span> name,</span></span></span><br><span class="line"><span class="params"><span class="function">        DateTime birthDate,</span></span></span><br><span class="line"><span class="params"><span class="function">        [CanBeNull] <span class="built_in">string</span> shortBio = <span class="literal">null</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check.NotNullOrWhiteSpace(name, <span class="keyword">nameof</span>(name));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> existingAuthor = <span class="keyword">await</span> _authorRepository.SingleOrDefaultAsync(t=&gt;t.Name == name);</span><br><span class="line">        <span class="keyword">if</span> (existingAuthor != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span> already exits&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Author(</span><br><span class="line">            GuidGenerator.Create(),</span><br><span class="line">            name,</span><br><span class="line">            birthDate,</span><br><span class="line">            shortBio</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ChangeNameAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        [NotNull] Author author,</span></span></span><br><span class="line"><span class="params"><span class="function">        [NotNull] <span class="built_in">string</span> newName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check.NotNull(author, <span class="keyword">nameof</span>(author));</span><br><span class="line">        Check.NotNullOrWhiteSpace(newName, <span class="keyword">nameof</span>(newName));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> existingAuthor = <span class="keyword">await</span> _authorRepository.SingleOrDefaultAsync(t=&gt;t.Name == newName);</span><br><span class="line">        <span class="keyword">if</span> (existingAuthor != <span class="literal">null</span> &amp;&amp; existingAuthor.Id != author.Id)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">$&quot;<span class="subst">&#123;newName&#125;</span> already exits&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        author.ChangeName(newName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后仍然是在DbContext中添加<code>DbSet&lt;Author&gt;</code>并执行迁移和更新,这点和Book部分一样.</p><p>接着定义DTO和ApplicationService<br>DTO:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GetAuthorListDto</span> : <span class="title">PagedAndSortedResultRequestDto</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Filter &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateAuthorDto</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">StringLength(35)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> DateTime BirthDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShortBio &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpdateAuthorDto</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">StringLength(35)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    <span class="keyword">public</span> DateTime BirthDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShortBio &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorDto</span> : <span class="title">EntityDto</span>&lt;<span class="title">Guid</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DateTime BirthDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShortBio &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>其中PagedAndSortedResultRequestDto</code> 具有标准分页和排序属性: <code>int MaxResultCount</code>, <code>int SkipCount</code>和 <code>string Sorting</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAuthorAppService</span> : <span class="title">IApplicationService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;AuthorDto&gt; <span class="title">GetAsync</span>(<span class="params">Guid id</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Task&lt;PagedResultDto&lt;AuthorDto&gt;&gt; GetListAsync(GetAuthorListDto input);</span><br><span class="line"></span><br><span class="line">    <span class="function">Task&lt;AuthorDto&gt; <span class="title">CreateAsync</span>(<span class="params">CreateAuthorDto input</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Task <span class="title">UpdateAsync</span>(<span class="params">Guid id, UpdateAuthorDto input</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Task <span class="title">DeleteAsync</span>(<span class="params">Guid id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>实现类略</em></p></blockquote><p>Auhtor功能完成后,可能会觉得领域服务和应用服务有点重叠,二者在实际开发中也确实不好区分,但是大体上而言应用服务是和<strong>用户&#x2F;使用侧相关的交互服务逻辑</strong>，关注的是应用场景,领域服务是和<strong>业务&#x2F;物体侧相关的内在服务逻辑</strong>，关注的是核心逻辑,比如电梯服务，应用服务偏用户使用侧包括按键、刷卡、高低层、奇偶层分流等，领域服务偏电梯自身属性和方法包括电梯上行、下行、开门、关门等。</p><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p>Auhtor类定义完成后,我们在Book中添加对应的实体外键:<code>Guid AuthorId</code>,虽然DDD最佳实践中要求仅通过id引用其它聚合对象. 但是, 你可以添加这样的导航属性</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ForeignKey(nameof(AuthorId))</span>]</span><br><span class="line"><span class="keyword">public</span> Author Author &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">````</span><br><span class="line">并为EF Core配置它. 这样, 你在获取图书和它们的作者时就不需要写<span class="keyword">join</span>查询了, 这会使代码简洁且逻辑清晰很多.</span><br><span class="line"></span><br><span class="line">大部分情况下EF Core都会自动识别依赖关系,但是如果定义了复杂导航属性,可能需要配置EF Core映射关系(这部分只是演示,这种简单映射其实不用处理):</span><br><span class="line">```csharp</span><br><span class="line">builder.Entity&lt;Book&gt;(b =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    b.ToTable(BookStoreConsts.DbTablePrefix + <span class="string">&quot;Books&quot;</span>, BookStoreConsts.DbSchema);</span><br><span class="line">    b.ConfigureByConvention(); <span class="comment">//auto configure for the base class props</span></span><br><span class="line">    b.Property(x =&gt; x.Name).IsRequired().HasMaxLength(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ADD THE MAPPING FOR THE RELATION</span></span><br><span class="line">    b.HasOne&lt;Author&gt;().WithMany().HasForeignKey(x =&gt; x.AuthorId).IsRequired();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样,在需要引用Book作者的时候,如果开启了EF Core预先加载,可以直接使用EBook.Author,或者使用<code>.Include(t=&gt;t.Author)</code>来显式加载.同时,在ABP的默认仓储中也封装了子对象加载,在获取导航属性的时候相当方便:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含子对象,单查询时默认开启</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TestWithDetails</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> book = <span class="keyword">await</span> _bookRepository.GetAsync(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不含子对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TestWithoutDetails</span>(<span class="params">Guid id</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> book = <span class="keyword">await</span> _bookRepository.GetAsync(id, includeDetails: <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合中包含子对象,默认关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TestWithDetails</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> books = <span class="keyword">await</span> _bookRepository.GetListAsync(includeDetails: <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以先查询不包含子对象的结果,再稍后获得其子对象:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order = <span class="keyword">await</span> _orderRepository.GetAsync(id, includeDetails: <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//order.Lines 此时是空的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> _orderRepository.EnsureCollectionLoadedAsync(order, x =&gt; x.Lines);</span><br><span class="line"><span class="comment">//order.Lines 被填充</span></span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>最上面说的<code>Module</code>配置类,其实就是ABP模块化的一个具体体现,定义模块由继承AbpModule实现:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogModule</span> : <span class="title">AbpModule</span></span><br><span class="line">&#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以重写ConfigureServices方法,入参ServiceConfigurationContext中可以拿到IServiceCollection,由此可以实现将配置项注入ASP.NET Core管道中.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlogModule</span> : <span class="title">AbpModule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">ServiceConfigurationContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时,Modoule中定义了PreConfigureServices和PostConfigureServices方法用来在ConfigureServices之前或之后执行配置.<br>如果模块之间具有相互依赖的逻辑,可以使用<code>[DependsOn(typeof(AbpAspNetCoreMvcModule))]</code>进行引用,ABP在启动时会调查应用程序的依赖关系,并以正确的顺序初始化&#x2F;关闭模块.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">领域驱动设计在互联网业务开发中的实践</a></li><li><a href="https://docs.abp.io/zh-Hans/abp/latest/Tutorials/Part-1">ABP-Web应用程序开发教程</a></li><li><a href="https://docs.abp.io/zh-Hans/abp/latest/Tutorials/Todo/Index?UI=BlazorServer&DB=EF">ABP-快速入门</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ABP </tag>
            
            <tag> 领域驱动 </tag>
            
            <tag> DDD </tag>
            
            <tag> ASP.NET Core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打造一个舒服的hexo编写环境</title>
      <link href="/2022/07/08/hello-world/"/>
      <url>/2022/07/08/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>如你所见,我清空了原有blog,似乎是种轮回,每隔那么久,几乎避免的会丢失一部分痕迹.要说直接原因,之前腾讯云的备份脚本不知道什么时候挂了,导致从年初开始一些文章都没有备份,结果就是我在换数据库的时候大手一按直接格式化.<br>再就是typecho的1.2版本更新带来的大量插件兼容问题,而使用的原有material主题作者已经不再维护,主题后台管理也出现了部分bug,虽然可以自行修复,但是实在不想再去研究php,material主题作者博客也切换到了hexo,我虽然早也有此想法,但是惰性和时间导致一直拖延到如今,再加上我和他一样,非常不喜欢无后端环境,也只怪typecho耗尽了最后一丝热情.<br>半个月前就开始琢磨迁移,但是直到最近才敲定,由于审美不太行,之前那个material风格的hexo版也已经停更两三年了,不得以采用了目前的Butterfly.虽然Butterfly非常不错,但是其本身的风格我是不太喜欢的,但是其它的就更不符合我审美了…</p><h2 id="编写环境"><a href="#编写环境" class="headerlink" title="编写环境"></a>编写环境</h2><p>Hexo的安装和其它配置没什么好说的,这些网上配置一大堆,不过值得说道的是本地编写中的VS Code部分,MarkDown支持的话VS Code默认就已经足够优秀,不过我依然安装了<code>GitHub Markdown Preview</code>和<code>Markdown All in One</code>,前者的话只是为了让自带的预览变成Github风格看起来更舒服些,后者则是为了某些环境需要导出md文件为html或者pdf,快捷键倒是其次.</p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>很难想象hexo版本迭代那么多次,默认的图片支持依然如此丑陋,3.0之前甚至必须得用异类标签引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>而Hexo 3.0虽然解决了这点,解决方式是开启配置文件中的post_asset_folder</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这开启之后每次Hexo New都会生成一个同名文件夹,可以把图片丢这里面引用,然后在生成静态文件的时候渲染引擎会将md的图片url映射到指定路径,但问题在于,这样线上会生效,但是在本地编写的时候VS Code渲染没有路径映射,只能靠脑部,我尝试去手动配置本地的图片渲染路径,但是貌似还没有直接的配置项,当然甚至可以专门去编写个插件,但这也颇为麻烦,加上文章文件夹下还放着一堆图片文件夹,强迫症实在忍不了.<br>为了解决这点,可以在VS Code中安装一个<code>Markdown Paste</code>插件,这可以将图片黏贴到md中并生成对应url,然后,在扩展设置中设置黏贴路径<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/hello-world/20220712132139.png"><br>我将其修改为文章上级的Imgs文件中,然后根据文章文件名建立文件夹.然后再在hexo的配置文件中关闭上文提到的post_asset_folder,但是另外两项仍然需要保持开启(映射url):</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这个时候,VS Code的本地渲染是正常的(如果不显示,可以把source文件夹打开为工作区,VS Code的安全策略会阻止读取父路径文件),渲染的静态文件也是正常的.按Ctrl+Alt+V(Windows)可以直接黏贴图片.</p><h2 id="评论插件"><a href="#评论插件" class="headerlink" title="评论插件"></a>评论插件</h2><p>目前采用的评论插件是Waline,除去国外哪些不符合使用习惯和审美的,比如来必力和FaceBook Comment之类,大致就Waline&#x2F;valine、gitalk这两类,至于托管其它服务商的那种我不太信任,文章可靠的同时也要保证评论不丢失,再加上这种大多缺少可自定义性.<br>gitalk这种插件最大的问题在于托管到Github的话指不定什么时候”被抽风”,国内这种错综复杂的网络环境一言难尽,然后每篇文章都需要去初始化,虽然写完之后是顺手的事,不过仍然难为我这种懒人.<br>Waline虽然还有一些小问题,比如CloudBase托管暂时有Bug之类的,不过无伤大雅,国内访问速度暂时还行,后期看看能不能弄个反代加速之类的.</p><h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>由于托管在Github Page,就可以用超棒的Github Actions代替我们去Hexo g和git push.<br>这里我将hexo分支作为page根路径,在hexo下的.github\workflows文件夹里创建一个deploy.yml,并写入自动构建配置项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># only push events on source branch trigger deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">hexo-deployment:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">Actions_Env</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> <span class="number">16</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span> <span class="string">&amp;</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        node -v</span></span><br><span class="line"><span class="string">        npm i hexo-cli -g</span></span><br><span class="line"><span class="string">        npm i hexo-generator-search hexo-render-pug --save</span></span><br><span class="line"><span class="string">        npm i</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo g</span></span><br><span class="line"><span class="string"></span>        </span><br><span class="line">    <span class="comment"># Output to branch `static` from `master`</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">        <span class="attr">publish_branch:</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>主分支(main或者master)和配置环境名需要自行更改,在Github的账号Setting中生成Token,然后在项目Setting–Environments配置即可.这样当你push新文章之后,GitHub Actions就会自动构建静态文件并提交到Hexo分支了.</p><hr><p>之前那个typecho的文章应该会有一些搬过来,但是大部分应该都废弃了,初期在写博客的时候,纯粹当成了个学习C#的笔记,记了很多废话,这样只顾数量不顾质量的结果就是大部分文章都没啥价值,早该被丢在尘埃里,之前是想的也许以后能帮到别人,但其文章本身也写得远不如其它能随手百度到的内容,这种以后还是尽量避免,即浪费时间也没什么意义.<br>后面如果有时间,希望能赶上以前的进度吧————这个有时间,对成年人而言太难了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
