<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASP.NET Core中的认证与授权</title>
      <link href="/2022/08/17/Authentication/"/>
      <url>/2022/08/17/Authentication/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>无论做什么应用,除非是完全公开的静态官网,总是会接触到认证与授权这两个概念.也许在小项目中这二者经常被混淆甚至误用,但是在现代化应用中,二者职责已相当分明,前者判断你是否合法,比如你登录爱奇艺时,认证中间件只判断账号密码是否正确,而当你点进一部新剧时,授权中间件则会对你账号的进行鉴权,比如是否有会员,是否有试看卷,通俗点来说,认证是鉴别用户是谁,而授权则是判断用户能做什么.</p><p>在ASP.NET core中认证是Authentication,授权是Authorization.也就是在项目入口中经常添加的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseAuthentication()</span><br><span class="line">app.UseAuthorization();</span><br></pre></td></tr></table></figure><p>不同于以前在PHP中随便写写Cookie login,现在对安全的提高和权限的细分,已经使传统的基于Cookie和Session的认证方式无法完成部分环境要求(比如前后端分离后,部分接口认证转向JWT,或者Oauth2的授权码模式),传统ASP.NET MVC应用中,通常使用IdentityServier或者直接在Controller校验后HttpClient.Sigin(),现在这种方式仍然予以保留.在ASP.NET Core中由于框架被细分(例如Blazor、WebAPI、grpc),对这块权限跨分极为精密,能做的更广也更为精确.  </p><h2 id="Cliam-标识-和ClaimsIdentity-证件"><a href="#Cliam-标识-和ClaimsIdentity-证件" class="headerlink" title="Cliam(标识)和ClaimsIdentity(证件)"></a>Cliam(标识)和ClaimsIdentity(证件)</h2><p>首先,ASP.NET Core中定义的最小身份信息是<code>Cliam</code>,原意是声明或者主张,不必在意翻译是否准确,可以将它理解为证件上的某一项标识,比如身份证上的姓名:张三、性别:男或者身份证号:101XXXXXXXXXXXX等等,这些都可以看成一个个键值对,Key是类型(CliamType/string),Value是具体值(string),并且这种键值对是可以重用的,比如你身份证和你驾照上的身份证上就有相同的标识,我们就不必去重复定义标识,不同标识可以组合成不同的证件,而这个”证件”在ASP.NET Core中是<code>ClaimsIdentity</code>,如果把前者理解为键值对,后者可以理解为<code>SortedList</code>(可重复键值对).有时候一个证件不足以证明一个人的身份,一个人也可以拥有多张证件.而这个证件持有人就是<code>ClaimsPrincipal </code>.  </p><p>想象一下,写字楼大门保安只看你的工牌是否属于写字楼里面某个楼层的公司,那他就没有必要在乎你上面的名字,而等你进入公司后,公司又需要判断你的级别,不至于把普通员工安排到总经理办公室.等你下班后,你小区的保安又需要你小区的门禁卡,即便你们公司的工牌上和门禁卡上的姓名标识是一样的,保安也不会看你的工牌就放你进去,但是如果你恰巧没带门禁卡,却带着房产证的话,看房产证的信息判断你是小区业主,依然可以放行.  </p><p>这几个场景下,要求的验证信息和方式各不相同不同,写字楼保安只在乎你的工牌上是否标识了某个公司,不管你是男是女;而公司需要你的工牌属于公司且需要查看工牌的身份信息;小区保安则要求你出示的是小区的门禁卡,至于你进入小区后怎么刷卡坐电梯那就是另一回事.应用到上面的<code>Cliam</code>和<code>ClaimsIdentity</code>,写字楼保安需要你的<code>Cliam</code>的Type是公司,Key是写字楼的某一项公司,并不关心你的ClaimsIdentity.而公司则需要你的<code>ClaimsIdentity</code>是XXX公司的工牌,并会查看你的<code>ClaimsIdentity</code>中<code>Cliam Type</code>为部门的值.而小区保安则判断你的<code>ClaimsPrincipal</code>是否为业主,而不在乎你拿什么证件来证明.</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>想象一下,如果需要自定义一个从数据库中验证并且有状态的Token认证,这和使用jwt或者其它token方案都不相同,那么需要如何操作呢?<br>在ASP.NET Core中,无论是认证还是授权,都是方案对应一个处理程序.其中,认证时的认证方案由<code>Authorize</code>特性的<code>AuthenticationSchemes</code>指定,所以,我们先需要添加一个认证方案:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddAuthentication(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    opt.AddScheme&lt;TokenAuthentication&gt;(<span class="string">&quot;CustomToken&quot;</span>, <span class="string">&quot;Token&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>认证方案添加了,在定义认证处理程序,认证方案需要实现IAuthenticationHandler:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenAuthentication</span> : <span class="title">IAuthenticationHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpContext _context = <span class="literal">default</span>!;</span><br><span class="line">    <span class="keyword">private</span> AppDbContext _dbContext = <span class="literal">default</span>!;</span><br><span class="line">    <span class="keyword">private</span> AuthenticationScheme _scheme = <span class="literal">default</span>!;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">InitializeAsync</span>(<span class="params">AuthenticationScheme scheme, HttpContext context</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _context = context;</span><br><span class="line">        _scheme = scheme;</span><br><span class="line">        <span class="keyword">await</span> Task.FromResult(_dbContext = context.RequestServices.GetRequiredService&lt;AppDbContext&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;AuthenticateResult&gt; <span class="title">AuthenticateAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> haveToken = _context.Request.Headers.TryGetValue(<span class="string">&quot;Authorization&quot;</span>, <span class="keyword">out</span> <span class="keyword">var</span> tokenHeader);</span><br><span class="line">        <span class="built_in">string</span> token = haveToken ? tokenHeader.ToString()[<span class="string">&quot;Bearer &quot;</span>.Length..] : <span class="built_in">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (haveToken &amp;&amp; <span class="keyword">await</span> _dbContext.Users.SingleOrDefaultAsync(t =&gt; t.Token == token) <span class="keyword">is</span> User user)<span class="comment">//验证token是否正确</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里的ClaimsIdentity构参scheme一定要和注入服务的scheme一样,除非此认证处理程序是默认的情况</span></span><br><span class="line">            ClaimsIdentity claimsIdentity = <span class="keyword">new</span> ClaimsIdentity(<span class="keyword">nameof</span>(TokenAuthentication));</span><br><span class="line">            claimsIdentity.AddClaims(<span class="keyword">new</span> Claim[]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> (ClaimTypes.Name, user.Name!),</span><br><span class="line">                <span class="keyword">new</span> (ClaimTypes.Sid, user.Id.ToString()!)</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//鉴权成功，写入用户信息</span></span><br><span class="line">            <span class="keyword">return</span> AuthenticateResult.Success(<span class="keyword">new</span> AuthenticationTicket(<span class="keyword">new</span> ClaimsPrincipal(claimsIdentity), _scheme.Name));</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> AuthenticateResult.NoResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ChallengeAsync</span>(<span class="params">AuthenticationProperties? properties</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.FromResult(_context.Response.StatusCode = <span class="number">401</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ForbidAsync</span>(<span class="params">AuthenticationProperties? properties</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.FromResult(_context.Response.StatusCode = <span class="number">403</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完事在控制器或者Action中指定Schemes即可:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize(AuthenticationSchemes = <span class="string">&quot;CustomToken&quot;</span>)</span>]</span><br></pre></td></tr></table></figure><h2 id="角色授权"><a href="#角色授权" class="headerlink" title="角色授权"></a>角色授权</h2><p>在传统应用中RBAC(基于角色的访问控制)大行其道,在现如今的后台管理中依然适用,比如上面励志中,只需要定义公司员工和小区业主身份,并对应添加允许通行、坐电梯、停地下停车场等权限,就可以根据不同身份控制权限,并且同一用户可以同时拥有多个角色.具有一定的灵活性.</p><p>在ASP.NET Core中仍旧支持此种授权方式,添加认证和鉴权中间件后,我们可以在控制器或者具体方法上使用<code>[Authorize]</code>特性的Role来控制其角色要求.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二者都可访问</span></span><br><span class="line">[<span class="meta">Authorize(Roles = <span class="string">&quot;Administrator, PowerUser&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ControlAllPanelController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">SetTime</span>()</span> =&gt;</span><br><span class="line">        Content(<span class="string">&quot;Administrator || PowerUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅支持Administrator访问</span></span><br><span class="line">    [<span class="meta">Authorize(Roles = <span class="string">&quot;Administrator&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">ShutDown</span>()</span> =&gt;</span><br><span class="line">        Content(<span class="string">&quot;Administrator only&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录的时候在ClaimsPrincipal中写入角色claim:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的ClaimsIdentity构参scheme一定要和注入服务的scheme一样,无论是默认还是自定义认证服务</span></span><br><span class="line"><span class="keyword">var</span> identity = <span class="keyword">new</span> ClaimsIdentity(<span class="keyword">new</span> ClaimsIdentity(CookieAuthenticationDefaults.AuthenticationScheme));</span><br><span class="line"><span class="comment">//自定义的claim信息</span></span><br><span class="line">identity.AddClaim(<span class="keyword">new</span> Claim(ClaimTypes.Role, <span class="string">&quot;Administrator&quot;</span>));</span><br><span class="line">identity.AddClaim(<span class="keyword">new</span> Claim(ClaimTypes.Role, <span class="string">&quot;PowerUser&quot;</span>));</span><br><span class="line">AuthenticationProperties properties = <span class="keyword">new</span> AuthenticationProperties()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置cookie票证的过期时间</span></span><br><span class="line">    ExpiresUtc = DateTime.Now.AddDays(<span class="number">7</span>),</span><br><span class="line">    RedirectUri = model.ReturnUrl</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">await</span> HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, <span class="keyword">new</span> ClaimsPrincipal(identity), properties);</span><br></pre></td></tr></table></figure><blockquote><p>由于ClaimsIdentity内的键值对是可重复的,所以可以直接Add多个同Type的Claim(<code>ClaimTypes.Role</code>).</p></blockquote><p>RBAC大行其道,但是在某些情况下它缺乏一定的灵活性,比如现在新开了个网吧,需要18岁以上的成年人才可进入,如果在这里加一个可进入酒吧的权限,那后面再多一个只准12岁以下进入的游乐场或者只准60岁以下进入的鬼屋,难不成都要逐个加么?</p><p>基于此种应用需求,微软引入了声明和策略授权.</p><h2 id="声明授权"><a href="#声明授权" class="headerlink" title="声明授权"></a>声明授权</h2><p>回到上面所述的,小区保安只关心你有没有小区业主的身份,也不关心具体在几栋在几楼,我们可以做如下定义:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line">builder.Services.AddRazorPages();</span><br><span class="line">builder.Services.AddControllersWithViews();</span><br><span class="line"></span><br><span class="line">builder.Services.AddAuthorization(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   options.AddPolicy(<span class="string">&quot;Owner&quot;</span>, policy =&gt; policy.RequireClaim(<span class="string">&quot;Residential&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line"></span><br><span class="line">app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">app.UseAuthentication();</span><br><span class="line"></span><br><span class="line">app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">app.MapDefaultControllerRoute();</span><br><span class="line"></span><br><span class="line">app.MapRazorPages();</span><br><span class="line"></span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure><p>在控制器或者Action上方标注授权要求:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Authorize(Policy = <span class="string">&quot;EnsureSafety&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">EnterCommunity</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> View();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然,也是支持多重策略应用的,比如进入小区保安只管你业主身份,但是单元楼楼下有个大妈防着小偷,一定要熟面孔才让进:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业主策略</span></span><br><span class="line">[<span class="meta">Authorize(Policy = <span class="string">&quot;Owner&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommunityController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">EnterCommunity</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//熟人策略</span></span><br><span class="line">    [<span class="meta">Authorize(Policy = <span class="string">&quot;Acquaintance&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">EnterUnitBuilding</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略授权"><a href="#策略授权" class="headerlink" title="策略授权"></a>策略授权</h2><p>上述声明授权中,虽然说的是声明授权,但是定义却是用的AddPolicy,这不是添加策略的意思么?<br>其实,策略可以看作声明和角色的并集,所以使用策略授权定义声明也就没什么好奇怪的了.</p><blockquote><p>基于角色的授权和基于声明的授权，只是一种语法上的便捷，最终都会生成授权策略</p></blockquote><p>接着是上面所说的网吧最低年龄这种限制,我们可以添加一个自定义授权策略:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义授权要求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MinimumAgeRequirement</span> : <span class="title">IAuthorizationRequirement</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinimumAgeRequirement</span>(<span class="params"><span class="built_in">int</span> minimumAge</span>)</span> =&gt;</span><br><span class="line">        MinimumAge = minimumAge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MinimumAge &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对授权要求使用处理程序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MinimumAgeHandler</span> : <span class="title">AuthorizationHandler</span>&lt;<span class="title">MinimumAgeRequirement</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task <span class="title">HandleRequirementAsync</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        AuthorizationHandlerContext context, MinimumAgeRequirement requirement</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dateOfBirthClaim = context.User.FindFirst(c =&gt; c.Type == ClaimTypes.DateOfBirth);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dateOfBirthClaim <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> dateOfBirth = Convert.ToDateTime(dateOfBirthClaim.Value);</span><br><span class="line">        <span class="built_in">int</span> calculatedAge = DateTime.Today.Year - dateOfBirth.Year;</span><br><span class="line">        <span class="keyword">if</span> (dateOfBirth &gt; DateTime.Today.AddYears(-calculatedAge))</span><br><span class="line">        &#123;</span><br><span class="line">            calculatedAge--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (calculatedAge &gt;= requirement.MinimumAge)</span><br><span class="line">        &#123;</span><br><span class="line">            context.Succeed(requirement);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理程序通过调用 context.Succeed(IAuthorizationRequirement requirement) 并传递已成功验证的要求来指示成功。</li><li>处理程序通常不需要处理失败，因为针对相同要求的其他处理程序可能会成功。</li><li>为了保证失败，即使其他要求处理程序成功，也需调用 context.Fail。</li></ul><p>添加自定义授权要求,并注入对应处理程序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddAuthorization(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.AddPolicy(<span class="string">&quot;AtLeast18&quot;</span>, policy =&gt;</span><br><span class="line">        policy.Requirements.Add(<span class="keyword">new</span> MinimumAgeRequirement(<span class="number">18</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">builder.Services.AddSingleton&lt;IAuthorizationHandler, MinimumAgeHandler&gt;();</span><br></pre></td></tr></table></figure><p>一个授权策略可以添加多个要求,可以按照需求添加多个要求甚至直接组合.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authorization/">ASP.NET Core 中的授权简介</a></li><li><a href="https://www.cnblogs.com/rainingnight/p/introduce-basic-authentication-in-asp-net-core.html">ASP.NET Core 认证与授权</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> asp.net core </tag>
            
            <tag> 认证 </tag>
            
            <tag> 鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打造一个舒服的hexo编写环境</title>
      <link href="/2022/07/08/hello-world/"/>
      <url>/2022/07/08/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>如你所见,我清空了原有blog,似乎是种轮回,每隔那么久,几乎避免的会丢失一部分痕迹.要说直接原因,之前腾讯云的备份脚本不知道什么时候挂了,导致从年初开始一些文章都没有备份,结果就是我在换数据库的时候大手一按直接格式化.<br>再就是typecho的1.2版本更新带来的大量插件兼容问题,而使用的原有material主题作者已经不再维护,主题后台管理也出现了部分bug,虽然可以自行修复,但是实在不想再去研究php,material主题作者博客也切换到了hexo,我虽然早也有此想法,但是惰性和时间导致一直拖延到如今,再加上我和他一样,非常不喜欢无后端环境,也只怪typecho耗尽了最后一丝热情.<br>半个月前就开始琢磨迁移,但是直到最近才敲定,由于审美不太行,之前那个material风格的hexo版也已经停更两三年了,不得以采用了目前的Butterfly.虽然Butterfly非常不错,但是其本身的风格我是不太喜欢的,但是其它的就更不符合我审美了…</p><h2 id="编写环境"><a href="#编写环境" class="headerlink" title="编写环境"></a>编写环境</h2><p>Hexo的安装和其它配置没什么好说的,这些网上配置一大堆,不过值得说道的是本地编写中的VS Code部分,MarkDown支持的话VS Code默认就已经足够优秀,不过我依然安装了<code>GitHub Markdown Preview</code>和<code>Markdown All in One</code>,前者的话只是为了让自带的预览变成Github风格看起来更舒服些,后者则是为了某些环境需要导出md文件为html或者pdf,快捷键倒是其次.</p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>很难想象hexo版本迭代那么多次,默认的图片支持依然如此丑陋,3.0之前甚至必须得用异类标签引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>而Hexo 3.0虽然解决了这点,解决方式是开启配置文件中的post_asset_folder</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这开启之后每次Hexo New都会生成一个同名文件夹,可以把图片丢这里面引用,然后在生成静态文件的时候渲染引擎会将md的图片url映射到指定路径,但问题在于,这样线上会生效,但是在本地编写的时候VS Code渲染没有路径映射,只能靠脑部,我尝试去手动配置本地的图片渲染路径,但是貌似还没有直接的配置项,当然甚至可以专门去编写个插件,但这也颇为麻烦,加上文章文件夹下还放着一堆图片文件夹,强迫症实在忍不了.<br>为了解决这点,可以在VS Code中安装一个<code>Markdown Paste</code>插件,这可以将图片黏贴到md中并生成对应url,然后,在扩展设置中设置黏贴路径<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../imgs/hello-world/20220712132139.png"><br>我将其修改为文章上级的Imgs文件中,然后根据文章文件名建立文件夹.然后再在hexo的配置文件中关闭上文提到的post_asset_folder,但是另外两项仍然需要保持开启(映射url):</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这个时候,VS Code的本地渲染是正常的(如果不显示,可以把source文件夹打开为工作区,VS Code的安全策略会阻止读取父路径文件),渲染的静态文件也是正常的.按Ctrl+Alt+V(Windows)可以直接黏贴图片.</p><h2 id="评论插件"><a href="#评论插件" class="headerlink" title="评论插件"></a>评论插件</h2><p>目前采用的评论插件是Waline,除去国外哪些不符合使用习惯和审美的,比如来必力和FaceBook Comment之类,大致就Waline/valine、gitalk这两类,至于托管其它服务商的那种我不太信任,文章可靠的同时也要保证评论不丢失,再加上这种大多缺少可自定义性.<br>gitalk这种插件最大的问题在于托管到Github的话指不定什么时候”被抽风”,国内这种错综复杂的网络环境一言难尽,然后每篇文章都需要去初始化,虽然写完之后是顺手的事,不过仍然难为我这种懒人.<br>Waline虽然还有一些小问题,比如CloudBase托管暂时有Bug之类的,不过无伤大雅,国内访问速度暂时还行,后期看看能不能弄个反代加速之类的.</p><h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>由于托管在Github Page,就可以用超棒的Github Actions代替我们去Hexo g和git push.<br>这里我将hexo分支作为page根路径,在hexo下的.github\workflows文件夹里创建一个deploy.yml,并写入自动构建配置项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># only push events on source branch trigger deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">hexo-deployment:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">Actions_Env</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> <span class="number">16</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span> <span class="string">&amp;</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        node -v</span></span><br><span class="line"><span class="string">        npm i hexo-cli -g</span></span><br><span class="line"><span class="string">        npm i hexo-generator-search hexo-render-pug --save</span></span><br><span class="line"><span class="string">        npm i</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo g</span></span><br><span class="line"><span class="string"></span>        </span><br><span class="line">    <span class="comment"># Output to branch `static` from `master`</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">        <span class="attr">publish_branch:</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>主分支(main或者master)和配置环境名需要自行更改,在Github的账号Setting中生成Token,然后在项目Setting–Environments配置即可.这样当你push新文章之后,GitHub Actions就会自动构建静态文件并提交到Hexo分支了.</p><hr><p>之前那个typecho的文章应该会有一些搬过来,但是大部分应该都废弃了,初期在写博客的时候,纯粹当成了个学习C#的笔记,记了很多废话,这样只顾数量不顾质量的结果就是大部分文章都没啥价值,早该被丢在尘埃里,之前是想的也许以后能帮到别人,但其文章本身也写得远不如其它能随手百度到的内容,这种以后还是尽量避免,即浪费时间也没什么意义.<br>后面如果有时间,希望能赶上以前的进度吧————这个有时间,对成年人而言太难了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
